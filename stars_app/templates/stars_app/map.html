<!-- inherit from base.html-->
{% extends "stars_app/base.html" %}

<!-- Replace block content in base_template.html -->
{% block content %}

<head>
	<meta charset="utf-8">
	<title>Guides</title>
	<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
	<link href="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css" rel="stylesheet">
	<script src="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js"></script>
	<link href="https://stackpath.bootstrapcdn.com/bootstrap/5.1.3/css/bootstrap.min.css" rel="stylesheet">
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/5.1.3/js/bootstrap.bundle.min.js"></script>
	<style>
		html, body {
			height: 100%;
			margin: 0;
			padding: 0;
			overflow: hidden;
		}

		#map {
			position: absolute;
			top: 0;
			bottom: 0;
			left: 0;
			right: 0;
			width: 100%;
			height: calc(100vh - 60px);
			margin-top: 60px;
		}
        .legend {
            position: absolute;
            padding-left: 10px;
            padding-right: 10px;
            bottom: 35px;
            right: 10px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.7);
        }

        .location-hover-popup h4, .cluster-hover-popup h4 {
            margin: 0 0 5px 0;
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }

        .location-hover-popup p, .cluster-hover-popup p {
            margin: 2px 0;
            color: #666;
        }

        .mapboxgl-popup-content h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: bold;
        }

        .mapboxgl-popup-content p {
            margin: 5px 0;
            font-size: 14px;
        }

        .mapboxgl-popup-content button {
            margin-top: 10px;
            width: 100%;
        }

        /* Button Styling */
        .debug-control, .control {
            background: white;
            border: none;
            cursor: pointer;
            padding: 7px 10px;
            margin: 10px;
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }

        .debug-control:hover, .control:hover {
            background: #d7d7d7;
        }

        .debug-control.active, .control.active {
            background: #ffebee;
            color: #ff0000;
        }

        /*.location-hover-popup, .cluster-hover-popup {
            /* Base styles for both popup types
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);

            border-radius: 12px;
            padding: 4px;
            font-size: 14px;
            pointer-events: none;

            transition: opacity 0.3s ease;
        }*/

        .tile-coordinates {
            border-radius: 8px;
            padding: 4px;
            font-size: 12px;
            pointer-events: none;

            transition: opacity 0.3s ease;
        }

        .tile-coordinates strong {
            font-size: 14px;
            font-weight: bold;
        }
	</style>
</head>
<body>
    {% csrf_token %}
	<div id="map"></div>

    <script>
        // API Service for handling all data fetching:
        class LocationService {
            static getCsrfToken() {
                return document.querySelector('[name=csrfmiddlewaretoken]').value;
            }

            static async getViewingLocations() {
                const response = await fetch('/api/viewing-locations/', {
                    headers: {
                        'Content-Type': 'applications/json',
                        'X-CSRFToken': this.getCsrfToken()
                    }
                });
                if (!response.ok) throw new Error('Failed to fetch viewing locations');
                return response.json();
            }

            static async getCelestialEvents() {
                const response = await fetch('/api/celestial-events/', {
                    headers: {
                        'Content-Type': 'applications/json',
                        'X-CSRFToken': this.getCsrfToken()
                    }
                });
                if (!response.ok) throw new Error('Failed to fetch celestial events');
                return response.json();
            }

            static async findOptimalLocations(bounds) {
                const response = await fetch(`/api/viewing-locations/find_optimal/?min_lit=${bounds.getSouth()}&max_lat=${bounds.getNorth()}&min_lon=${bounds.getWest()}&max_lon=${bounds.getEast()}`, {
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.getCsrfToken()
                    }
                });
                if (!response.ok) throw new Error('Failed to find optimal locations');
                return response.json();
            }
        }

        // Class for debugging map features:
        class MapDebugger {
            constructor(map) {
                this.map = map;
                this.tileDebugEnabled = false;
                this.pixelDebugEnabled = false;
                this.currentTileLayer = null;
                this.updateTimeout = null;

                this.selectedTile = null;

                // Add throttled update on move
                this.map.on('move', () => {
                    if (!this.updateTimeout) {
                        this.updateTimeout = setTimeout(() => {
                            this.updateTileGrid();
                            if (this.pixelDebugEnabled) {
                                this.updatePixelGrid();
                            }
                            this.updateTimeout = null;
                        }, 16); // Approximately 60fps (1000ms / 60)
                    }
                });

                // Final update when movement ends
                this.map.on('moveend', () => {
                    if (this.updateTimeout) {
                        clearTimeout(this.updateTimeout);
                        this.updateTimeout = null;
                    }
                    this.updateTileGrid();
                });
            }

            // TILE DEBUG FUNCTIONS: ---------------------------- //

            toggleTileDebug() {
                if (this.tileDebugEnabled) {
                    // Remove existing tile debug layers
                    if (this.map.getLayer('tile-debug-grid')) {
                        this.map.removeLayer('tile-debug-grid');
                    }
                    if (this.map.getSource('tile-debug-source')) {
                        this.map.removeSource('tile-debug-source');
                    }
                    this.tileDebugEnabled = false;
                } else {
                    // Create a grid source for the current zoom level
                    const zoom = Math.floor(this.map.getZoom());
                    const bounds = this.map.getBounds();

                    // Calculate tile boundaries
                    const gridFeatures = this.createTileGrid(
                        bounds.getWest(),
                        bounds.getSouth(),
                        bounds.getEast(),
                        bounds.getNorth(),
                        zoom
                    );

                    // Add source and layer for tile grid
                    this.map.addSource('tile-debug-source', {
                        'type': 'geojson',
                        'data': {
                            'type': 'FeatureCollection',
                            'features': gridFeatures
                        }
                    });

                    this.map.addLayer({
                        'id': 'tile-debug-grid',
                        'type': 'line',
                        'source': 'tile-debug-source',
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        'paint': {
                            'line-color': '#FF0000',
                            'line-width': 2,
                            'line-opacity': 1
                        }
                    });

                    this.tileDebugEnabled = true;
                }
            }

            createTileGrid(west, south, east, north, zoom) {
                const features = [];

                // Add bounds limiting to prevent pole issues
                south = Math.max(south, -85.0511); // Limit south to prevent projection issues
                north = Math.min(north, 85.0511);  // Limit north to prevent projection issues

                // Calculate tile ranges with safety checks
                const n = Math.pow(2, zoom);
                const west_tile = Math.floor((west + 180) / 360 * n);
                const east_tile = Math.ceil((east + 180) / 360 * n);

                // Add safety checks for latitude calculations
                const south_lat_rad = Math.max(-85.0511 * Math.PI / 180, south * Math.PI / 180);
                const north_lat_rad = Math.min(85.0511 * Math.PI / 180, north * Math.PI / 180);

                const south_tile = Math.floor((1 - Math.log(Math.tan(south_lat_rad) + 1 / Math.cos(south_lat_rad)) / Math.PI) / 2 * n);
                const north_tile = Math.ceil((1 - Math.log(Math.tan(north_lat_rad) + 1 / Math.cos(north_lat_rad)) / Math.PI) / 2 * n);

                // Add limit to number of tiles to prevent excessive calculations
                const MAX_TILES = 1000; // Arbitrary limit to prevent browser crashes
                const tile_count = (east_tile - west_tile) * (south_tile - north_tile);

                if (tile_count > MAX_TILES) {
                    console.warn('Too many tiles to display, zoom in for more detail');
                    return features;
                }

                try {
                    // Create vertical lines (longitude boundaries)
                    for (let x = west_tile; x <= east_tile; x++) {
                        const lon = x * 360 / n - 180;
                        features.push({
                            'type': 'Feature',
                            'geometry': {
                                'type': 'LineString',
                                'coordinates': [
                                    [lon, Math.max(-85.0511, south)],
                                    [lon, Math.min(85.0511, north)]
                                ]
                            },
                            'properties': {
                                'type': 'vertical'
                            }
                        });
                    }

                    // Create horizontal lines (latitude boundaries)
                    for (let y = north_tile; y <= south_tile; y++) {
                        // Add safety check for latitude calculation
                        try {
                            const lat = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
                            if (lat >= -85.0511 && lat <= 85.0511) {  // Only add if within safe bounds
                                features.push({
                                    'type': 'Feature',
                                    'geometry': {
                                        'type': 'LineString',
                                        'coordinates': [
                                            [west, lat],
                                            [east, lat]
                                        ]
                                    },
                                    'properties': {
                                        'type': 'horizontal'
                                    }
                                });
                            }
                        } catch (e) {
                            console.warn('Skipping invalid latitude calculation');
                            continue;
                        }
                    }
                } catch (e) {
                    console.error('Error creating tile grid:', e);
                    return [];  // Return empty features on error
                }

                return features;
            }

            updateTileGrid() {
                if (this.tileDebugEnabled) {
                    try {
                        const bounds = this.map.getBounds();
                        const zoom = Math.floor(this.map.getZoom());

                        // Check if we're too close to poles
                        if (bounds.getNorth() > 85.0511 || bounds.getSouth() < -85.0511) {
                            console.warn('Too close to poles, tile debug may be inaccurate');
                            return;  // Optionally return to prevent updates near poles
                        }

                        const gridFeatures = this.createTileGrid(
                            bounds.getWest(),
                            bounds.getSouth(),
                            bounds.getEast(),
                            bounds.getNorth(),
                            zoom
                        );

                        const source = this.map.getSource('tile-debug-source');
                        if (source) {
                            source.setData({
                                'type': 'FeatureCollection',
                                'features': gridFeatures
                            });
                        }
                    } catch (e) {
                        console.error('Error updating tile grid:', e);
                        // Optionally disable tile debug if there's an error
                        this.tileDebugEnabled = false;
                    }
                }
            }

            // PIXEL DEBUG FUNCTIONS: --------------------------- //

            createPixelGrid(west, south, east, north, zoom) {
                const features = [];
                const tileSize = 256; // Standard tile size

                if(!this.selectedTile) {
                    return features;
                }

                // Only create pixel grid for the selected tile:
                const { x: x_tile, y: y_tile } = this.selectedTile;

                // Calculate bounds for just this tile
                const n = Math.pow(2, zoom);
                const tile_west = x_tile * 360 / n - 180;
                const tile_east = (x_tile + 1) * 360 / n - 180;
                const tile_north = Math.atan(Math.sinh(Math.PI * (1 - 2 * y_tile / n))) * 180 / Math.PI;
                const tile_south = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y_tile + 1) / n))) * 180 / Math.PI;

                // Only show pixel grid when zoomed in enough
                if (zoom < 8) {
                    console.warn('Zoom in to see pixel grid');
                    return features;
                }

                // Create grid for each pixel in the selected tile
                for (let px = 0; px < tileSize; px++) {
                    for (let py = 0; py < tileSize; py++) {
                        const pixel_west = tile_west + (tile_east - tile_west) * px / tileSize;
                        const pixel_east = tile_west + (tile_east - tile_west) * (px + 1) / tileSize;
                        const pixel_north = tile_north + (tile_south - tile_north) * py / tileSize;
                        const pixel_south = tile_north + (tile_south - tile_north) * (py + 1) / tileSize;

                        features.push({
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: [
                                    [pixel_west, pixel_north],
                                    [pixel_east, pixel_north],
                                    [pixel_east, pixel_south],
                                    [pixel_west, pixel_south],
                                    [pixel_west, pixel_north]
                                ]
                            },
                            properties: {
                                type: 'pixel',
                                tile_x: x_tile,
                                tile_y: y_tile,
                                pixel_x: px,
                                pixel_y: py
                            }
                        });
                    }
                }
                return features;
            }

            // Add click handler for selecting tiles
            setupTileSelection() {
                this.map.on('click', (e) => {
                    if (this.pixelDebugEnabled) {
                        const zoom = Math.floor(this.map.getZoom());
                        const coords = this.getTileCoordinates(e.lngLat.lng, e.lngLat.lat, zoom);

                        // Update selected tile
                        this.selectedTile = {
                            x: coords.x,
                            y: coords.y,
                            z: coords.z
                        };

                        // Update the pixel grid
                        this.updatePixelGrid();
                    }
                });
            }

            togglePixelDebug() {
                if (this.pixelDebugEnabled) {
                    if (this.map.getLayer('pixel-debug-grid')) {
                        this.map.removeLayer('pixel-debug-grid');
                    }
                    if (this.map.getSource('pixel-debug-source')) {
                        this.map.removeSource('pixel-debug-source');
                    }
                    this.selectedTile = null; // Reset selected tile
                    this.pixelDebugEnabled = false;
                } else {
                    this.map.addSource('pixel-debug-source', {
                        'type': 'geojson',
                        'data': {
                            'type': 'FeatureCollection',
                            'features': []  // Start empty until a tile is selected
                        }
                    });

                    this.map.addLayer({
                        'id': 'pixel-debug-grid',
                        'type': 'line',
                        'source': 'pixel-debug-source',
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        'paint': {
                            'line-color': '#00FF00',
                            'line-width': 0.5,
                            'line-opacity': 0.1
                        }
                    });

                    this.pixelDebugEnabled = true;
                    this.setupTileSelection(); // Setup click handling
                }
            }

            updatePixelGrid() {
                if (this.pixelDebugEnabled) {
                    const bounds = this.map.getBounds();
                    const zoom = Math.floor(this.map.getZoom());

                    const source = this.map.getSource('pixel-debug-source');
                    if (source) {
                        source.setData({
                            'type': 'FeatureCollection',
                            'features': this.createPixelGrid(
                                bounds.getWest(),
                                bounds.getSouth(),
                                bounds.getEast(),
                                bounds.getNorth(),
                                zoom
                            )
                        });
                    }
                }
            }

            addDebugControls() {
                // Tile debug control button:
                const debugButton = document.createElement('button');
                debugButton.className = 'mapboxgl-ctrl-group mapboxgl-ctrl debug-control';
                debugButton.innerHTML = 'Show Tile Borders';
                debugButton.onclick = () => {
                    this.toggleTileDebug();
                    debugButton.innerHTML = this.tileDebugEnabled ? 'Hide Tile Borders' : 'Show Tile Borders';
                    debugButton.classList.toggle('active', this.tileDebugEnabled);
                };
                this.map.getContainer().appendChild(debugButton);

                // Pixel debug control button:
                const pixelDebugButton = document.createElement('button');
                pixelDebugButton.className = 'mapboxgl-ctrl-group mapboxgl-ctrl debug-control';
                pixelDebugButton.innerHTML = 'Show Pixel Grid';
                pixelDebugButton.onclick = () => {
                    this.togglePixelDebug();
                    this.selectedTile = null;
                    pixelDebugButton.innerHTML = this.pixelDebugEnabled ? 'Hide Pixel Grid' : 'Show Pixel Grid';
                    pixelDebugButton.classList.toggle('active', this.pixelDebugEnabled);
                };
                this.map.getContainer().appendChild(pixelDebugButton);

                // Update popup styling
                this.map.on('click', (e) => {
                    if (this.tileDebugEnabled) {
                        const zoom = Math.floor(this.map.getZoom());
                        const tile = this.getTileCoordinates(e.lngLat.lng, e.lngLat.lat, zoom);

                        new mapboxgl.Popup({
                            closeButton: false,
                            className: 'tile-debug-popup',
                        })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="tile-coordinates">
                                <strong>Tile Information</strong><br>
                                X: ${tile.x}<br>
                                Y: ${tile.y}<br>
                                Zoom: ${zoom}<br>
                            </div>
                        `)
                        .addTo(this.map);
                    }
                });
            }

            getTileCoordinates(lng, lat, zoom) {
                // Convert lng/lat to tile coordinates
                const n = Math.pow(2, zoom);
                const x = Math.floor((lng + 180) / 360 * n);
                const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
                return { x, y, z: zoom };
            }
        }

        // Map controller class for drawing layers, user interaction:
        class MapController {
            constructor() {
                this.map = null;
                this.currentPopover = null;
                this.markers = new Map();
                this.userInteracting = false;
                this.spinEnabled = true;
                this.secondsPerRevolution = 180;
                this.maxSpinZoom = 5;
                this.slowSpinZoom = 3;

                this.debugger = null;
            }

            initialize() {
                mapboxgl.accessToken = 'pk.eyJ1IjoiamN1YmVyZHJ1aWQiLCJhIjoiY20yMHNqODY3MGtqcDJvb2MzMXF3dHczNCJ9.yXIqwWQECN6SYhppPQE3PA';
                this.map = new mapboxgl.Map({
                    container: 'map',

                    // For other styles:
                    // https://docs.mapbox.com/api/maps/styles/
                    style: 'mapbox://styles/mapbox/standard',
                    projection: 'globe',
                    zoom: 1,
                    center: [-105.35, 39.113014],
                    fog: {
                        'space-color': '#000000',
                        'star-intensity': 0.6,
                        'color': '#242B4B',
                        'high-color': '#161B36',
                        'horizon-blend': 0.02,
                    }
                });

                this.map.on('load', () => {
                    this.addControls();
                    this.setupEventListeners();
                    this.initializeDataLayers();
                    this.setupDarkSkyLayer();

                    // Initialize the debugger after dark sky layer:
                    this.debugger = new MapDebugger(this.map);
                    this.debugger.addDebugControls();

                    this.map.setFog({
                        'space-color': '#000000',
                        'star-intensity': 1.0,
                        'color': '#242B4B',
                        'high-color': '#161B36',
                        'horizon-blend': 0.02
                    });

                    this.map.addSource('mapbox-dem', {
                        'type': 'raster-dem',
                        'url': 'mapbox://mapbox.terrain-rgb',
                        'tileSize': 512,
                        'maxzoom': 14
                    });
                    this.map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });

                    this.loadLocationsAndEvents();
                });

                this.spinGlobe();
            }

            addControls() {
                this.map.addControl(new mapboxgl.NavigationControl());
                this.map.addControl(new mapboxgl.GeolocateControl({
                    positionOptions: { enableHighAccuracy: true },
                    trackUserLocation: true,
                    showUserHeading: true
                }));
            }

            setupEventListeners() {
                this.map.on('mousedown', () => this.userInteracting = true);
                this.map.on('dragstart', () => this.userInteracting = true);
                this.map.on('click', () => this.removeCurrentPopover());
                this.map.on('moveend', () => this.spinGlobe());

                // Add right-click event listener:
                this.map.on('contextmenu', (e) => {
                    // Get coordinates from click event
                    const coordinates = e.lngLat;

                    // Create popup content with coordinates and quality score
                    const popupContent = `
                        <div style="padding: 10px;">
                            <h4>Location Info</h4>
                            <p>Longitude: ${coordinates.lng.toFixed(6)}</p>
                            <p>Latitude: ${coordinates.lat.toFixed(6)}</p>
                            <button onclick="addLocation(${coordinates.lng}, ${coordinates.lat})"
                                    class="btn btn-sm btn-primary">
                                Add Location
                            </button>
                        </div>
                    `;

                    // Create and show popup
                    new mapboxgl.Popup()
                        .setLngLat(coordinates)
                        .setHTML(popupContent)
                        .addTo(this.map);
                });
            }

            initializeDataLayers() {
                console.log('Initializing data layers...');

                // Add viewing locations source:
                this.map.addSource('viewing-locations', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: []
                    },
                    cluster: true,
                    clusterMaxZoom: 14,
                    clusterRadius: 50
                });

                // Add clusters layer:
                console.log('Adding clusters layer...');
                this.map.addLayer({
                    id: 'location-clusters',
                    type: 'circle',
                    source: 'viewing-locations',
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#51bbd6',
                            100, '#f1f075',
                            750, '#f28cb1',
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            20, 100, 30, 750, 40
                        ]
                    }
                });

                // Add individual locations layer:
                console.log('Adding individual locations layer...');
                this.map.addLayer({
                    id: 'viewing-locations',
                    type: 'circle',
                    source: 'viewing-locations',
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'quality_score'],
                            0, '#ff0000',
                            50, '#ffff00',
                            100, '#00ff00',
                        ],
                        'circle-radius': 8
                    }
                });

                // Add hover interaction for individual locations:
                this.map.on('mouseenter', 'viewing-locations', (e) => {
                    this.map.getCanvas().style.cursor = 'pointer';

                    // Get the location data from the feature:
                    const coordinates = e.features[0].geometry.coordinates.slice();
                    const properties = e.features[0].properties;

                    const getQualityClass = (score) => {
                        if (score >= 75) return 'quality-high';
                        if (score >= 50) return 'quality-medium';
                        return 'quality-low';
                    };

                    // Create popup content:
                    const popupContent = `
                        <div class="location-popup">
                            <h4>${properties.name}</h4>
                            <p>Quality Score: ${properties.quality_score}</p>
                            <p>Elevation: ${properties.elevation} m</p>
                            ${properties.light_pollution_value ?
                                `<p>Light Pollution: ${properties.light_pollution_value}</p>` :
                                ''}
                        </div>
                    `;

                    // Create and show the popup:
                    new mapboxgl.Popup({
                        closeButton: false,
                        className: 'location-hover-popup'
                    })
                    .setLngLat(coordinates)
                    .setHTML(popupContent)
                    .addTo(this.map);
                });

                // Remove popup when mouse leaves the loation:
                this.map.on('mouseleave', 'viewing-locations', () => {
                    this.map.getCanvas().style.cursor = '';
                    const popups = document.getElementsByClassName('location-hover-popup');
                    if (popups[0]) popups[0].remove();
                });

                // Add hover interactions for clusters
                this.map.on('mouseenter', 'location-clusters', (e) => {
                    this.map.getCanvas().style.cursor = 'pointer';

                    const coordinates = e.features[0].geometry.coordinates.slice();
                    const pointCount = e.features[0].properties.point_count;

                    // Create popup content for clusters
                    const popupContent = `
                        <div class="cluster-popup">
                            <h4>Location Cluster</h4>
                            <p>${pointCount} locations in this area</p>
                        </div>
                    `;

                    new mapboxgl.Popup({
                        closeButton: false,
                        className: 'cluster-hover-popup'
                    })
                    .setLngLat(coordinates)
                    .setHTML(popupContent)
                    .addTo(this.map);
                });

                // Remove cluster popup on mouseleave
                this.map.on('mouseleave', 'location-clusters', () => {
                    this.map.getCanvas().style.cursor = '';
                    const popups = document.getElementsByClassName('cluster-hover-popup');
                    if (popups[0]) popups[0].remove();
                });
            }

            setupDarkSkyLayer() {
                // Add dark sky source and layer:
                this.map.addSource('dark-sky', {
                    type: 'raster',
                    tiles: ['/tiles/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: 'Dark Sky Data © NASA Earth Observatory',
                    bounds: [-180, -85.0511, 180, 85.0511],
                    minzoom: 0,
                    maxzoom: 8
                });

                this.map.addLayer({
                    id: 'dark-sky-layer',
                    type: 'raster',
                    source: 'dark-sky',
                    paint: {
                        'raster-opacity': 0.7,
                        'raster-fade-duration': 0
                    }
                });

                this.addDarkSkyControls();
            }

            addDarkSkyControls() {
                // Add toggle button
                const toggleButton = this.createControl('Toggle Dark Sky', () => {
                    const visibility = this.map.getLayoutProperty('dark-sky-layer', 'visibility');
                    this.map.setLayoutProperty(
                        'dark-sky-layer',
                        'visibility',
                        visibility === 'visible' ? 'none' : 'visible'
                    );
                });

                // Add find optimal locations button
                const findOptimalButton = this.createControl('Find Best Viewing Locations', async () => {
                    try {
                        const bounds = this.map.getBounds();
                        const locations = await LocationService.findOptimalLocations(bounds);
                        this.displayOptimalLocations(locations);
                    } catch (error) {
                        console.error('Error finding optimal locations:', error);
                    }
                });

                // Add legend
                this.addLegend();
            }

            createControl(text, onClick) {
                const button = document.createElement('button');
                button.className = 'mapboxgl-ctrl-group mapboxgl-ctrl control';
                button.innerHTML = text;
                button.onclick = onClick;
                this.map.getContainer().appendChild(button);
                return button;
            }

            addLegend() {
                const legend = document.createElement('div');
                legend.className = 'mapboxgl-ctrl-group mapboxgl-ctrl legend';
                legend.innerHTML = `
                    <h4>Dark Sky Levels</h4>
                    <div style="display: flex; align-items: center; margin: 5px 0;">
                        <div style="background: linear-gradient(to right, black, floralwhite); width: 100px; height: 20px;"></div>
                        <span style="margin-left: 10px;">Light Pollution Scale</span>
                    </div>
                `;
                this.map.getContainer().appendChild(legend);
            }

            async loadLocationsAndEvents() {
                try {
                    console.log('Starting to load locations and events...');

                    const [locations, events] = await Promise.all([
                        LocationService.getViewingLocations(),
                        //LocationService.getCelestialEvents()
                    ]);
                    console.log('Locations fetched:', locations);


                    if (locations && locations.length > 0) {
                        console.log(`Found ${locations.length} locations to display`);
                        this.displayLocations(locations);
                    } else {
                        console.log('No locations received');
                    }

                    if (events && events.length > 0) {
                        console.log(`Found ${events.length} events to display`);
                        this.displayEvents(events);
                    } else {
                        console.log('No events received');
                    }


                } catch (error) {
                    console.error('Error loading data:', error);
                }
            }

            displayLocations(locations) {
                console.log('Attempting to display locations:', locations);

                try {
                    const features = locations.map(location => ({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [location.longitude, location.latitude]
                        },
                        properties: {
                            id: location.id,
                            name: location.name || 'Unnamed Location',
                            elevation: parseFloat(location.elevation) || 0,

                            quality_score: parseFloat(location.quality_score) || 0,
                            light_pollution_value: parseFloat(location.light_pollution_value) || 0
                        }
                    }));

                    const source = this.map.getSource('viewing-locations');
                    if (!source) {
                        console.error('Source "viewing-locations" not found');
                        return;
                    }
                    console.log('Setting data with features:', features);

                    source.setData({
                        type: 'FeatureCollection',
                        features
                    });

                } catch (error) {
                    console.error('Error displaying locations:', error);
                }
            }

            displayEvents(events) {
                events.forEach(event => {
                    const marker = new mapboxgl.Marker({
                        color: '#CC00CC',
                        draggable: false
                    })
                    .setLngLat([
                        parseFloat(event.location.longitude),
                        parseFloat(event.location.latitude)
                    ])
                    .addTo(this.map);

                    marker.getElement().addEventListener('click', (e) => {
                        this.showEventPopover(marker, event);
                        e.stopPropagation();
                    });

                    this.markers.set(event.id, marker);
                });
            }

            showEventPopover(marker, event) {
                this.removeCurrentPopover();

                const popover = document.createElement('div');
                popover.className = 'popover hide';

                popover.innerHTML = `
                    <div class='event-name'>${event.name}</div>
                    <div>Type: ${event.event_type}</div>
                    <div>Viewing Radius: ${event.viewing_radius} km</div>
                    <div>Peak Time: ${new Date(event.start_time).toLocaleString()}</div>
                `;

                marker.getElement().appendChild(popover);
                requestAnimationFrame(() => popover.classList.remove('hide'));
                this.currentPopover = popover;

                this.map.flyTo({
                    center: [event.location.longitude, event.location.latitude],
                    zoom: 5,
                    essential: true
                });
            }

            removeCurrentPopover() {
                if (this.currentPopover) {
                    this.currentPopover.classList.add('hide');
                    setTimeout(() => this.currentPopover.remove(), 300);
                    this.currentPopover = null;
                }
            }

            spinGlobe() {
                const zoom = this.map.getZoom();
                if (this.spinEnabled && !this.userInteracting && zoom < this.maxSpinZoom) {
                    let distancePerSecond = 360 / this.secondsPerRevolution;
                    if (zoom > this.slowSpinZoom) {
                        const zoomDif = (this.maxSpinZoom - zoom) / (this.maxSpinZoom - this.slowSpinZoom);
                        distancePerSecond *= zoomDif;
                    }
                    const center = this.map.getCenter();
                    center.lng -= distancePerSecond;
                    this.map.easeTo({ center, duration: 1000, easing: (n) => n });
                }
            }
        }

        // Function to add a location when right clicking:
        async function addLocation(longitude, latitude) {
             try {
                const response = await fetch('/api/viewing-locations/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: JSON.stringify({
                        name: `Location at ${latitude.toFixed(2)}, ${longitude.toFixed(2)}`,
                        latitude: latitude,
                        longitude: longitude,
                        elevation: 0  // We could fetch actual elevation data here
                    })
                });

                if (response.ok) {
                    // Refresh the locations on the map
                    const mapController = window.mapController;  // We'll need to make this accessible
                    await mapController.loadLocationsAndEvents();

                    // Close any open popups
                    const popups = document.getElementsByClassName('mapboxgl-popup');
                    if (popups.length) {
                        popups[0].remove();
                    }
                } else {
                    console.error('Failed to add location');
                }
            } catch (error) {
                console.error('Error adding location:', error);
            }
        }

        // Initialize the map when the document is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.mapController = new MapController();
            window.mapController.initialize();
        });
    </script>
</body>
{% endblock %}

